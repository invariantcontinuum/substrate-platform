# =============================================================================
# Policies Mock Data
# Structural Integrity Platform - OPA/Rego Policy Definitions
# =============================================================================

regoTemplates:
  apiEnforcement: |
    package substrate.api
    
    import future.keywords.if
    import future.keywords.in
    
    # Deny API calls without mTLS
    deny contains msg if {
        input.request.protocol != "mTLS"
        msg := sprintf("API call to %s must use mTLS", [input.request.service])
    }
    
    # Deny services not in allowlist
    deny contains msg if {
        not input.request.service in data.allowed_services
        msg := sprintf("Service %s is not in the allowed services list", [input.request.service])
    }

  circularDependency: |
    package substrate.dependencies
    
    import future.keywords.if
    import rego.v1
    
    # Detect circular imports using graph.reachable
    circular_dependency contains cycle if {
        some component
        data.architecture.dependencies[component]
        some neighbor in data.architecture.dependencies[component]
        reachable := graph.reachable(data.architecture.dependencies, {neighbor})
        component in reachable
        cycle := {
            "component": component,
            "via": neighbor,
            "msg": sprintf("Circular: '%s' -> '%s' -> ... -> '%s'", [component, neighbor, component])
        }
    }
    
    # Limit dependency depth
    deny contains msg if {
        input.dependency_depth > 5
        msg := "Dependency depth exceeds maximum allowed (5)"
    }

  gdprCompliance: |
    package substrate.gdpr
    
    import future.keywords.if
    import future.keywords.in
    
    # PII fields that require encryption
    pii_fields := {"email", "ssn", "phone", "address", "dob"}
    
    # Deny unencrypted PII storage
    deny contains msg if {
        some field in input.schema.fields
        field.name in pii_fields
        not field.encrypted
        msg := sprintf("PII field %s must be encrypted", [field.name])
    }
    
    # Require data residency in EU
    deny contains msg if {
        input.data_classification == "PII"
        not input.storage.region in {"eu-west-1", "eu-central-1", "eu-north-1"}
        msg := "PII data must be stored in EU regions (GDPR Article 44)"
    }
    
    # Require @Private decorator for PII access
    deny contains msg if {
        some field in input.accessed_fields
        field.name in pii_fields
        not field.has_decorator("@Private")
        msg := sprintf("PII field %s access lacks @Private decorator", [field.name])
    }

  licenseCompliance: |
    package substrate.licenses
    
    import future.keywords.if
    import future.keywords.in
    
    # Forbidden licenses
    forbidden_licenses := {"GPL-2.0", "GPL-3.0", "AGPL-3.0", "SSPL-1.0"}
    
    # Deny forbidden licenses
    deny contains msg if {
        input.dependency.license in forbidden_licenses
        msg := sprintf("Dependency %s uses forbidden license %s", [input.dependency.name, input.dependency.license])
    }
    
    # Require license whitelist for production
    deny contains msg if {
        input.environment == "production"
        not input.dependency.license in data.whitelisted_licenses
        msg := sprintf("License %s not whitelisted for production", [input.dependency.license])
    }

  secretManagement: |
    package substrate.secrets
    
    import future.keywords.if
    import future.keywords.regex
    
    # Pattern for detecting API keys
    api_key_pattern := `[A-Za-z0-9_]{32,}`
    
    # Deny hardcoded secrets
    deny contains msg if {
        regex.match(api_key_pattern, input.code)
        not input.is_test_file
        msg := sprintf("Potential hardcoded secret detected in %s", [input.file_path])
    }
    
    # Require vault injection
    deny contains msg if {
        input.requires_secret
        not input.secret_source == "vault"
        msg := "Secrets must be injected via Vault, not environment variables"
    }
    
    # Deny secrets in logs
    deny contains msg if {
        input.logs[_] contains api_key_pattern
        msg := "Potential secret leak in log output"
    }

  layerViolation: |
    package substrate.layers
    
    import future.keywords.if
    import rego.v1
    
    # Layer definitions (lower number = lower layer)
    layer_order := {
        "presentation": 4,
        "application": 3,
        "domain": 2,
        "infrastructure": 1,
        "data": 0
    }
    
    # Detect layer violations - lower layers should not depend on higher layers
    layer_violation contains violation if {
        some source, targets in data.architecture.dependencies
        some target in targets
        layer_order[data.architecture.component_layers[source]] < layer_order[data.architecture.component_layers[target]]
        violation := {
            "source": source,
            "target": target,
            "msg": sprintf("Layer violation: '%s' (%s) depends on '%s' (%s)",
                [source, data.architecture.component_layers[source], target, data.architecture.component_layers[target]])
        }
    }

policies:
  - id: pol-api-gateway
    name: API Gateway Enforcement
    description: Enforces mTLS and service allowlist for all internal API communications
    package: substrate.api
    status: Enforced
    severity: Critical
    rules: 12
    violations: 0
    regoKey: apiEnforcement
    metadata:
      author: Platform Team
      created: "2024-01-15"
      updated: "2024-08-20"
      tags: [security, api, mtls]
    enforcement:
      mode: Strict
      scope: [production, staging]
      autoRemediate: false

  - id: pol-circular-dep
    name: Circular Dependency Guard
    description: Prevents circular imports and limits dependency depth to maintain architecture integrity
    package: substrate.dependencies
    status: Enforced
    severity: High
    rules: 4
    violations: 1
    regoKey: circularDependency
    metadata:
      author: Architecture Team
      created: "2024-02-10"
      updated: "2024-09-01"
      tags: [architecture, dependencies, code-quality]
    enforcement:
      mode: Strict
      scope: [all]
      autoRemediate: true

  - id: pol-gdpr-data
    name: GDPR Data Residency
    description: Ensures PII data is encrypted at rest and stored in EU regions only
    package: substrate.gdpr
    status: Warning
    severity: Critical
    rules: 18
    violations: 2
    regoKey: gdprCompliance
    metadata:
      author: Compliance Team
      created: "2024-03-01"
      updated: "2024-08-15"
      tags: [compliance, gdpr, privacy, encryption]
    enforcement:
      mode: Warn
      scope: [production, eu-regions]
      autoRemediate: false

  - id: pol-license
    name: License Compliance
    description: Blocks dependencies with copyleft licenses in production environments
    package: substrate.licenses
    status: Enforced
    severity: Medium
    rules: 8
    violations: 0
    regoKey: licenseCompliance
    metadata:
      author: Legal Tech
      created: "2024-04-20"
      updated: "2024-07-30"
      tags: [legal, licenses, compliance]
    enforcement:
      mode: Strict
      scope: [production]
      autoRemediate: true

  - id: pol-secrets
    name: Secret Management
    description: Prevents hardcoded secrets and enforces vault-based secret injection
    package: substrate.secrets
    status: Enforced
    severity: Critical
    rules: 6
    violations: 3
    regoKey: secretManagement
    metadata:
      author: Security Team
      created: "2024-05-10"
      updated: "2024-09-05"
      tags: [security, secrets, vault]
    enforcement:
      mode: Strict
      scope: [all]
      autoRemediate: false

  - id: pol-layers
    name: Layer Violation Detection
    description: Enforces clean architecture layer dependencies
    package: substrate.layers
    status: Warning
    severity: High
    rules: 3
    violations: 1
    regoKey: layerViolation
    metadata:
      author: Architecture Team
      created: "2024-06-15"
      updated: "2024-09-10"
      tags: [architecture, layers, clean-code]
    enforcement:
      mode: Warn
      scope: [all]
      autoRemediate: false

  - id: pol-rate-limit
    name: Rate Limiting
    description: Enforces rate limits on API endpoints to prevent abuse
    package: substrate.rate_limit
    status: Draft
    severity: Medium
    rules: 3
    violations: 0
    rego: |
      package substrate.rate_limit
      import future.keywords.if
      
      default_rate_limit := 1000
      
      deny contains msg if {
          input.request_count > default_rate_limit
          msg := sprintf("Rate limit exceeded: %d requests (limit: %d)", [input.request_count, default_rate_limit])
      }
    metadata:
      author: SRE Team
      created: "2024-09-01"
      updated: "2024-09-10"
      tags: [reliability, rate-limiting, sre]
    enforcement:
      mode: DryRun
      scope: [staging]
      autoRemediate: false

severityLevels:
  Critical:
    color: red
    value: 4
  High:
    color: orange
    value: 3
  Medium:
    color: yellow
    value: 2
  Low:
    color: blue
    value: 1

statusConfig:
  Enforced:
    color: emerald
    icon: ShieldCheck
    description: Policy is actively blocking violations
  Warning:
    color: amber
    icon: AlertTriangle
    description: Policy violations generate warnings
  Draft:
    color: slate
    icon: FileEdit
    description: Policy is in draft mode, not enforced
  Disabled:
    color: gray
    icon: Ban
    description: Policy is disabled

enforcementModes:
  Strict: Block all violations
  Warn: Log warnings only
  DryRun: Audit mode, no action
